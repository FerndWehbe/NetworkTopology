{% extends 'base.html' %}

{% block header %}
<h1>{% block title %}Desenha Topology{% endblock %}</h1>
{% endblock %}

{% block content %}
<style>
    #edit {
        display: flex;
        flex-direction: row-reverse;
    }

    #edit>button {
        margin: 5px;
    }

    #edit>h4 {
        position: absolute;
        left: 50%;
        text-anchor: middle;
    }
</style>
<script src="{{ url_for('static', filename='js/d3.v7.min.js') }}"></script>
<div id="edit">
    <h4>{{ file.strip(".json").replace("_", " ") }}</h4>
    <button class="edit-buttons" onclick="location.href='/editar/?file_name={{ file }}'">Editar</button>
</div>
<div id="chart">
    <svg>
    </svg>
</div>

<script>
    var margin = {
            top: 20,
            right: 90,
            bottom: 30,
            left: 90
        },
        width = 1920 - margin.left - margin.right,
        height = 500 - margin.top - margin.bottom,
        list_vlans = []

    var svg = d3.select("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", `translate(${margin.left}, ${margin.top})`)

    var root

    var tree = d3.tree()
        .size([height, width])

    d3.json("/static/arquivos_json/{{file}}").then(data => {
        console.log(data)

        root = d3.hierarchy(data, d => d.children)

        root.x0 = height / 2
        root.y0 = 0

        var div_tooltip = d3.select("div.toolTip")

        update(root)


    })

    update = (source) => {
        var treeData = tree(root)

        var nodes = treeData.descendants(),
            links = treeData.descendants().slice(1),
            i = 0,
            duration = 250

        recusiveCount(source.data, list_vlans)

        list_vlans = [...new Set(list_vlans)]

        var colors = d3.scaleLinear()
            .range(d3['schemeDark2'])
            .domain(list_vlans)


        nodes.forEach(el => el.depth == 1 ? el.y = 180 : el.y = el.depth * 180)

        var node = svg.selectAll("g.node")
            .data(nodes, d => d.id || (d.id = ++i))

        var nodeEnter = node.enter()
            .append("g")
            .classed("node", true)
            .attr("transform", d => `translate(${source.y0}, ${source.x0})`)
            .on("click", click)

        nodeEnter.append("circle")
            .classed("node", true)
            .style("color", "blue")
            .style("stroke", "steelblue")
            .style("stroke-width", "1.5px")
            .style("fill", "lightsteelblue")
            .attr("r", 8)

        nodeEnter.append("text")
            .attr("id", "namelocation")
            .attr("style",
                "font: 11px sans-serif; fill: black; text-shadow: -1px 0 white, 0 1px white, 1px 0 white, 0 -1px white;"
            )
            .attr("x", 12)
            .attr("dy", "-0.5em")
            .attr("text-anchor", "start")
            .text(d => {
                if (d.data.Name && d.data.Location) return `${d.data.Name} - ${d.data.Location}`
                if (d.data.Name) return d.data.Name
                if (d.data.Location) return d.data.Location
                return ""
            })

        nodeEnter.append("text")
            .attr("id", "ipaddres")
            .attr("style",
                "font: 11px sans-serif; fill: black; text-shadow: -1px 0 white, 0 1px white, 1px 0 white, 0 -1px white;"
            )
            .attr("x", 12)
            .attr("y", 18)
            .attr("dy", "-0.5em")
            .attr("text-anchor", "start")
            .text(d => `${d.data.ipaddress ? d.data.ipaddress : ' '}`)

        nodeEnter.append("text")
            .attr("id", "uplink-text")
            .attr("style",
                "font: 11px sans-serif; fill: black; text-shadow: -1px 0 white, 0 1px white, 1px 0 white, 0 -1px white;"
            )
            .attr("x", -24)
            .attr("dy", ".25em")
            .attr("text-anchor", "start")
            .text(d => `${d.data.uplink ? d.data.uplink : " "}`)

        // Update Nodes

        var nodeUpdate = nodeEnter.merge(node)

        nodeUpdate.transition()
            .duration(duration)
            .attr("transform", d => `translate(${d.y}, ${d.x})`);

        //Atualiza os atributos e estilos do nó

        nodeUpdate.select('circle.node')
            .attr('r', 8)
            .attr('cursor', 'pointer');


        nodeUpdate.select('text#namelocation')
            .text(d => {
                if (d.data.Name && d.data.Location) return `${d.data.Name} - ${d.data.Location}`
                if (d.data.Name) return d.data.Name
                if (d.data.Location) return d.data.Location
                return ""
            })


        nodeUpdate.select('text#ipaddres')
            .text(d => `${d.data.ipaddress ? d.data.ipaddress : ' '}`)

        nodeUpdate.select('text#uplink-text')
            .text(d => `${d.data.uplink ? d.data.uplink : " "}`)

        //Exclui os nós removidos

        var nodeExit = node.exit()
            .transition()
            .duration(duration)
            .attr('transform', d => `translate(${source.y}, ${source.x})`)
            .remove();

        //Reduz o tamanho do nó para 0 antes de remover

        nodeExit.select('circle')
            .attr('r', 0);


        // # ============= Links ============= #

        var link = svg.selectAll('path.link')
            .data(links, d => d.id)

        var linkEnter = link.enter()
            .insert('path', 'g')
            .attr('class', 'link')
            .attr('d', d => {
                var o = {
                    x: source.x0,
                    y: source.y0
                }
                return diagonal(o, o)
            })
            .attr("style", "fill: none; stroke-width: 3px;")
            .attr("stroke", d => {
                if (!d.data.vlans) return "#14aecc"
                var node_vlans = d.data.vlans
                if (node_vlans.length == 1) return colors(node_vlans[0])
                return colors(node_vlans[1])
            })

        var linkUpdate = linkEnter.merge(link);

        linkUpdate
            .transition()
            .duration(duration)
            .attr('d', function (d) {
                return diagonal(d, d.parent)
            })

        var linkExit = link.exit()

            .transition()
            .duration(duration)
            .attr('d', function (d) {
                // style_link(linkUpdate)
                var o = {
                    x: source.x,
                    y: source.y
                }
                return diagonal(o, o)
            })
            .remove();


        nodes.forEach(d => {
            d.x0 = d.x;
            d.y0 = d.y;
        })
    }

    click = (event, d) => {
        if (d.children) {
            d._children = d.children;
            d.children = null;
        } else {
            d.children = d._children;
            d._children = null;
        }
        update(d);
    }

    diagonal = (s, d) => {

        // O css não conseque aplicar gradiente em paths que não possuem curvaturas.
        // Para solucionar esse problema o if checa se o path é uma linha reta, caso seja
        // É aplicado uma level curvatura no inicio e final do path para enganar o css e aplicar o gradiente. 

        if (`${(s.y + d.y) / 2} ${s.x}` == `${(s.y + d.y) / 2} ${d.x}`) {
            path = `M ${s.y} ${s.x}
            C ${(s.y + d.y) / 2} ${s.x - 0.0011},
                ${(s.y + d.y) / 2} ${d.x + 0.0011},
                ${d.y} ${d.x}`
        } else {
            path = `M ${s.y} ${s.x}
            C ${(s.y + d.y) / 2} ${s.x},
                ${(s.y + d.y) / 2} ${d.x},
                ${d.y} ${d.x}`
        }
        return path
    }

    parseVlans = (value) => {
        var parsed = value.split(",").map(value => parseInt(value.trim()))
        return parsed
    }

    recusiveCount = (data, list_vlans) => {
        if (data.vlans) {
            data.vlans.forEach(vlan => list_vlans.push(vlan))
        }
        if (data.children) {
            data.children.forEach(el => recusiveCount(el, list_vlans))
        }
    }
</script>

{% endblock %}